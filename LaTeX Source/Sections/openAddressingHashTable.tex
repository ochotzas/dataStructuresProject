\subsection*{Περιγραφή}

Ενώ ο στόχος μιας συνάρτησης κατακερματισμού είναι η ελαχιστοποίηση των συγκρούσεων, ορισμένες συγκρούσεις είναι αναπόφευκτες στην πράξη. Έτσι, οι εφαρμογές κατακερματισμού πρέπει να περιλαμβάνουν κάποια μορφή πολιτικής επίλυσης σύγκρουσης. Οι τεχνικές επίλυσης σύγκρουσης μπορούν να χωριστούν σε δύο κατηγορίες: ανοιχτό κατακερματισμό και κλειστό κατακερματισμό (ονομάζεται επίσης ανοιχτής διεύθυνσης). Η διαφορά μεταξύ των δύο έχει να κάνει με το εάν οι συγκρούσεις αποθηκεύονται εκτός πίνακα (δηλαδή με συνδεδεμένες λίστες) ή εάν οι συγκρούσεις έχουν ως αποτέλεσμα την αποθήκευση στον ίδιο πίνακα.

Ωστόσο, το θέμα των συγκρούσεων θα μπορούσε να βελτιωθεί, αν και αυτό δεν σημαίνει ότι θα αποτρέψουμε όλες τις συγκρούσεις, αλλά μπορούμε να μειώσουμε την πιθανότητα δυο λέξεις να συγκρουστούν, δηλαδή να έχουν το ίδιο \en hash key \gr. Μια καλή και ευρέως χρησιμοποιούμενη συνάρτηση υπολογισμού του \en hash \gr μιας συμβολοσειράς βρίσκεται παρακάτω (με κάποιες βελτιώσεις - βάση του αλγορίθμου μας).

\bigskip

\noindent Έστω $s$ μια συμβολοσειρά και $q$ το μέγεθος του πίνακα. Έχουμε:

\begin{align*}
    hash(s) &= \frac{1}{q} \left( s[0] + s[1] \cdot p + s[2] \cdot p^2 + \ldots + s[n-1] \cdot p^{n-1} \mod m \right) \\
    &=  \frac{1}{q} \left( \sum_{i=0}^{n-1} s[i] \cdot p^i \mod m \right)
\end{align*}

\noindent όπου $p = 31$ και $m = 1e9 + 9$ \footnote[1]{Περισσότερα για την συνάρτησή στο άρθρο: \en https://cp-algorithms.com/string/string-hashing.html \gr }.

\bigskip

\en
\begin{listing}[ht]
\begin{minted}[frame=lines, framesep=1em]{cpp}

#pragma once
#include <string>

using std::string;

class HashNode
{
public:
    HashNode(string word, int key, int times)
    {
        this->word = word;
        this->key = key;
        this->times = times;
    }
    string word;
    unsigned int key, times;
};

\end{minted}
\caption{Υλοποίηση του \en HashNode \gr για τον πίνακα κατακερματισμού με ανοιχτή διεύθυνση}
\label{listing:9}
\end{listing}
\gr

Για την υλοποίηση της δομής η λογική που ακολουθήθηκε είναι να δημιουργήσουμε ένα  \en Hash Node \gr όπου θα αποθηκεύουμε την λέξη, το κλειδί και τις φορές που υπάρχει μέσα στην δομή. Ουσιαστικά, με τη βοήθεια του \en Hash Node \gr θα μπορούμε να διαχειριζόμαστε δυναμικά, γρηγορότερα και ευκολότερα την δομή μας.

Προχωρώντας στην υλοποίηση της κεντρικής κλάσης για τον πίνακα κατακερματισμού με ανοιχτή διεύθυνση, αρχικά, ορίζουμε ότι θέλουμε να χρησιμοποιήσουμε μια μεταβλητή που θα αποθηκεύει τον χώρο, μια τα στοιχεία τα οποία εισήχθησαν και τέλος έναν πίνακα τύπου \en HashNode \gr (βλ. Πρόγραμμα \ref{listing:9}).

Στο \en protected \gr τμήμα της κλάσης έχουμε την συνάρτηση \en getKey \gr, όπου μετατρέπει μια λέξη σε αριθμό, την \en Get \gr όπου επιστρέφει συγκεκριμένη διεύθυνση του πίνακα, την \en Hash \gr όπου υπολογίζει το κλειδί και τέλος την \en nextHash \gr όπου υπολογίζουμε το επόμενο κλειδί.

Στο \en public \gr τμήμα της κλάσης έχουμε τον κατασκευαστή, την συνάρτηση όπου θα εισάγει λέξεις μέσα στη δομή και την συνάρτηση που θα αναζητεί (βλ. Πρόγραμμα \ref{listing:10}).

\en
\begin{listing}[ht]
\begin{minted}[frame=lines, framesep=1em]{cpp}

#pragma once
#include <string>

using std::string;

class Hashing
{
private:
    unsigned long long int Size;
    unsigned long long int Elements;
    HashNode** Table;
protected:
    long long getKey(const string&);
    HashNode*& Get(const int&, const string&);
    unsigned int Hash(const int&);
    unsigned int nextHash(unsigned int);
public:
    Hashing();
    ~Hashing();
    bool Insert(const string&);
    bool Find(string&, unsigned int &);
};

\end{minted}
\caption{Υλοποίηση της κλάσης για τον πίνακα κατακερματισμού με ανοιχτή διεύθυνση}
\label{listing:10}
\end{listing}
\gr



\subsection{Μέθοδος εισαγωγής}

Η σκεπτική πλευρά της μεθόδου εισαγωγής προγραμματιστικά θα λέγαμε ότι είναι απλή (βλ. Πρόγραμμα \ref{listing:11}). Αρχικά, ελέγχουμε αν η διεύθυνση η οποία μας επέστρεψε η συνάρτηση \en Get \gr (ουσιαστικά, η διεύθυνση μιας συγκεκριμένης θέσης του πίνακα - με βάση το \en key \gr και την λέξη) είναι κενή ή όχι. Σε περίπτωση που χρησιμοποιείται τότε επιστρέφουμε \en false \gr, δηλαδή ότι δεν μπόρεσε η συγκεκριμένη λέξη να εισαχθεί. Διαφορετικά προχωρούμε κανονικά ελέγχοντας αν μας επαρκεί η μνήμη που έχουμε. Αν έχει ήδη γεμίσει το μισό του πίνακα τότε διπλασιάζουμε τον χώρο με κύριο κριτήριο οι λέξεις να εισαχθούν στον νέο πίνακα με την περισσότερη μνήμη με βάση την συνάρτησή \en Hash \gr, για να μπορούμε οποιαδήποτε στιγμή να αναζητήσουμε οποιοδήποτε στοιχείο επιθυμούμε. Στη συνέχεια εκχωρούμε την λέξη. Η περίπτωση μια λέξη να υπάρχει ήδη στον πίνακα ελέγχεται από την συνάρτηση \en Get \gr την οποία θα δούμε στο κεφάλαιο με την μέθοδο αναζήτησης.

\en
\begin{listing}[ht]
\begin{minted}[frame=lines, framesep=1em]{cpp}

bool Hashing::Insert(const string& word)
{
    int key = getKey(word);

    if (Get(key, word) != nullptr)
        return false;

    if (Elements * 2 >= Size)
    {
        Size *= 2;
        HashNode** temp;

        temp = new (std::nothrow) HashNode*[Size];
        for (int i = 0; i < Size; i++)
            temp[i] = nullptr;

        for (int i = 0; i < Size / 2; i++)
        {
            if (Table[i] != nullptr)
            {
                unsigned int p = Hash(Table[i]->key);

                while (temp[p] != nullptr)
                    p = nextHash(p);

                temp[p] = Table[i];
                Table[i] = nullptr;
            }
        }

        delete[] Table;
        Table = temp;
    }

    unsigned int HashIndex = Hash(key);
    while (Table[HashIndex] != nullptr)
        HashIndex = nextHash(HashIndex);

    Table[HashIndex] = new HashNode(word, key, 0); Elements++;
    return true;
}

\end{minted}
\caption{Δημιουργία της συνάρτησής \en Insert \gr του πίνακα κατακερματισμού με ανοιχτή διεύθυνση}
\label{listing:11}
\end{listing}
\gr


\subsection{Μέθοδος αναζήτησής}

Όπως φαίνεται και στο Πρόγραμμα \ref{listing:12}, η συνάρτηση \en Find \gr δέχεται δύο ορίσματα. Το πρώτο όρισμα δέχεται τη λέξη την οποία θέλουμε να εξετάσουμε αν υπάρχει μέσα στη δομή (η συνάρτηση δέχεται τη λέξη αναφορικά για να μη γίνει άσκοπη αντιγραφή) και το δεύτερο όρισμα τη μεταβλητή που χρησιμοποιούμε για να επιστρέψουμε το σύνολο εμφανίσεων της κάθε λέξης στο σύνολο όλων των λέξεων που έχει αποθηκεύσει η δομή. Η επιστροφή του συνόλου εμφανίσεων μιας λέξης γίνεται με την χρήση αναφορικής μεταβλητής.

Εντός της συνάρτησης, αρχικά ορίζουμε σε μια μεταβλητή το \en HashKey \gr που επιστρέφεται από την συνάρτηση \en Hash \gr και έπειτα δημιουργούμε μια μεταβλητή που θα αποθηκεύει διεύθυνση που επιστρέφει η συνάρτηση \en Get \gr. Ο τρόπος λειτουργίας της συνάρτησης \en Get \gr είναι ο εξής:

\begin{enumerate}
    \item Σε μια μεταβλητή $p$, αποθήκευσε το \en Hash Key \gr.
    \item Καθώς κάθε θέση του πίνακα έχει στοιχεία εξέτασε για κάθε θέση του πίνακα αν η λέξη που είναι αποθηκευμένη είναι ίδια με αυτή που υπάρχει ως παράμετρο. Αν ισχύει, τότε αύξησε το πλήθος της λέξης κατά μια μονάδα και επέστρεψε τη θέση του πίνακα με τις ιδιότητες του. Διαφορετικά, πήγαινε στην επόμενη θέση με βάση τη συνάρτηση \en nextHash \gr.
    \item Σε περίπτωση που δεν ισχύει το παραπάνω, τότε επιστρέφουμε τη θέση του πίνακα με τις ιδιότητες της.
\end{enumerate}

Στη συνέχεια, αφού έχει κληθεί και έχει επιστραφεί κάποιο αποτέλεσμα από την συνάρτηση \en Get \gr, εξετάζουμε αν η μεταβλητή $p$ δείνχει σε κάποια διεύθυνση θέσης του πίνακα ή όχι. Αν δεν δείχνει κάπου τότε επιστρέφουμε \en false \gr, διαφορετικά με αναφορά εκχωρούμε τις τιμές στις αντίστοιχες αναφορικές μεταβλητές \en times \gr και \en word \gr. Τέλος επιστρέφουμε \en true \gr.

\en
\begin{listing}[ht]
\begin{minted}[frame=lines, framesep=1em]{cpp}

bool Hashing::Find(string& word, unsigned int& times)
{
    int key = getKey(word);
    HashNode* p = Get(key, word);

    if (p == nullptr)
        return false;

    times = p->times;
    word = p->word;

    return true;
}

HashNode*& Hashing::Get(const int& key, const string& word)
{
    unsigned int p = Hash(key);
    while (Table[p] != nullptr)
    {
        if (Table[p]->word == word
        {
            Table[p]->times++;
            return Table[p];
        }

        p = nextHash(p);
    }

    return Table[p];
}

\end{minted}
\caption{Δημιουργία της συνάρτησής \en Find \gr και \en Get \gr του πίνακα κατακερματισμού με ανοιχτή διεύθυνση}
\label{listing:12}
\end{listing}
\gr

\subsection{Σχολιασμός και χρόνοι εκτέλεσης}

Ο χρόνος εισαγωγής σε έναν έναν πίνακα κατακερματισμού είναι λιγότερος σε σχέση με όλες τις προηγούμενες δομές. Ο καθορισμός της θέσης που θα αποθηκευτεί το κάθε στοιχείο ορίζεται πολυωνυμικά με βάση την παραπάνω συνάρτηση που υπάρχει στην περιγραφή. Σε περίπτωση, όπως αναφέρθηκε, που δεν βρεθεί ψάχνει σε άλλη -- επόμενη -- θέση, με βάση τη συνάρτηση \en nextHash \gr (βλ. Πρόγραμμα \ref{listing:12}) όπου δεν 'κοστίζει' πολύ σε πολυπλοκότητα.

\gr
\begin{table}[!h]
\centering
\begin{tabular}{||c c c||} 
 \hline
 Δομή & Χρόνος Εισαγωγής & Χρόνος Αναζήτησης/10χιλ. λέξεις \\
 \hline\hline
  Πίνακας κατακερματισμού με ανοιχτή διεύθυνση & 48.971 δευτερόλεπτα & 7.552 δευτερόλεπτα \\
 \hline
\end{tabular}
\caption{Χρόνοι εκτέλεσης εισαγωγής και αναζήτησης για τον πίνακα κατακερματισμού με ανοιχτή διεύθυνση}
\label{table:5}
\end{table}

Όσο για την αναζήτηση, όπου η διαδικασία που ακολουθείται που ακολουθείτε είναι ακριβώς η ίδια (Αλγοριθμικά περιγράφεται στο Πρόγραμμα \ref{listing:12}) ο χρόνος σε σχέση με τις προηγούμενες τέσσερις δομές έχει μεγάλη απόκλιση, λόγω της δομής του πίνακα κατακερματισμού. Μεγάλη βελτίωση στην εισαγωγή πραγματοποίησε η συνάρτηση όπου αναφέρεται στην περιγραφή, λόγω λιγότερων συγκρούσεων. 