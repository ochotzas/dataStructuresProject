\subsection*{Περιγραφή}

Η δομή ενός μη ταξινομημένου πίνακα είναι μια συλλογή στοιχείων όπου κάθε στοιχείο κατέχει μια σχετική θέση σε σχέση με τα άλλα.

Γενικά, ένας μη ταξινομημένος πίνακας είναι μια δομή δεδομένων που τα στοιχεία του είναι διατεταγμένα με βάση τη σειρά που εισήχθησαν στον πίνακα. Κάθε στοιχείο του πίνακα διαπερνάται με τη σειρά, έτσι για παράδειγμα η αναζήτηση γίνεται σειριακά έως ότου βρεθεί το επιθυμητό στοιχείο, διαφορετικά η σύγκριση συνεχίζεται μέχρι τέλους του πίνακα.


\begin{table}[h!]
\centering
\begin{tabular}{||c c c c||} 
 \hline
 Θέση $i$ στοιχείου & Περίπτωση & Συγκρίσεις & Πολυπλοκότητα \\
 \hline\hline
 $0$ & Καλύτερή & $1$ & $O(1)$ \\ 
 $n-1$ & Χειρότερή & $n$ & $O(n)$ \\ 
 \hline
\end{tabular}
\caption{Περιπτώσεις της σειριακής αναζήτησης}
\label{table:1}
\end{table}


Για να μελετήσουμε θεωρητικά τις δυο περιπτώσεις ενός αλγορίθμου θα πρέπει να το δούμε υπό μαθηματικής άποψης. Έστω ότι $n$ το σύνολο των στοιχείων και $i$ η θέση του κάθε στοιχείου στον πίνακα. Η \textbf{καλύτερη περίπτωση} είναι το στοιχείο που αναζητούμε να βρίσκεται στη πρώτη θέση του πίνακα ($i=0$). Αντίστοιχα, η \textbf{χειρότερη περίπτωση} θα ήταν αν το στοιχείο που αναζητούμε είναι το τελευταίο στοιχείο του πίνακα ($i=n-1$) ή το στοιχείο που αναζητούμε να μην περιεχόταν στο πίνακα (βλ. Πίνακας \ref{table:1}).

Πριν ξεκινήσουμε να υλοποιούμε την εισαγωγή, αναζήτηση και διαγραφή του μη ταξινομημένου πίνακα \en (unorderedArray), \gr  θα πρέπει να ξεκινήσουμε την υλοποίηση της κλάσης.


\en
\begin{listing}[ht]
\begin{minted}[frame=lines, framesep=1em]{cpp}

#pragma once
#include <string>

using std::string;

class unorderedArray
{
private:
    struct Arr
    {
        string value;
        long long unsigned int times;
    };
    Arr* Array;
    long long unsigned int FirstFreeCell;
protected:
    bool ReallocateArray(int);
public:
    unorderedArray();
    ~unorderedArray();
    
    void Insert(string);  
    bool Delete(string);
    bool Find(string, long long unsigned int&, long long unsigned int&);
    long long unsigned int getFirstFreeCell() { return FirstFreeCell; }

    string& operator[](unsigned int possition) { return Array[possition].value; }
};

\end{minted}
\caption{Υλοποίηση της κλάσης για τον αταξινόμητο πίνακα}
\label{listing:1}
\end{listing}
\gr


Όπως φαίνεται παραπάνω (Πρόγραμμα \ref{listing:1}), κατασκευάζουμε εντός της κλάσης της \en UnorderedArray \gr ένα \en struct \gr το όποιο αποθηκεύει την λέξη μας καθώς και πόσες φορές αποθηκεύεται στον παρακάτω πίνακα.

Διατηρούμε την πρώτη ελεύθερη θέση σε μια μεταβλητή τύπου \en long long unsigned int \gr για να βεβαιωθούμε πως θα φτάσουν τα \en bytes \gr για την αποθήκευση του πλήθους λέξεων που θα αποθηκευτούν $+1$ θέση, όπου θα είναι η ελεύθερη θέση.

Στο δημόσιο τμήμα της κλάσης της αταξινόμητης τομής, υπάρχει ο κατασκευαστής, καταστροφέας και διάφορες συναρτήσεις τις οποίες θα μελετήσουμε παρακάτω.

\subsection{Μέθοδος εισαγωγής}

Ας υποθέσουμε ότι έχουμε έναν δυναμικό πίνακα με $n$ θέσεις και $i$ θα ονομάσουμε το κάθε στοιχείο του πίνακα με $i\in[0,n)$ και $j$ το στοιχείο που θέλουμε να εισάγουμε στον πίνακα. Σε έναν μη ταξινομημένο πίνακα, η λειτουργία εισαγωγής είναι ταχύτερη σε σύγκριση με έναν ταξινομημένο πίνακα επειδή δεν χρειάζεται να ενδιαφερόμαστε για τη θέση στην οποία πρόκειται να τοποθετηθεί το στοιχείο.

Κάθε στοιχείο $j$ θα τοποθετείτε στην τελευταία θέση του πίνακα. Για να λύσουμε το θέμα του πλήρη πίνακα, κάθε φορά θα δεσμεύουμε $n+1$ θέσεις για κάθε $j$ στοιχείο. Επομένως, ας δημιουργήσουμε δύο συναρτήσεις της κλάσης μας όπου η πρώτη συνάρτηση θα πραγματοποιεί την εισαγωγή στοιχείων στην τελευταία θέση του πίνακα και δεύτερων τη συνάρτηση που θα δεσμεύει νέα μνήμη.

Πρακτικά, στην δική μας υλοποίηση, λαμβάνοντας υπόψιν ότι θέλουμε να γνωρίζουμε και το πλήθος εμφανίσεων κάθε λέξης, χρησιμοποιούμε την συνάρτηση \en Find \gr για να εντοπίσουμε αν η λέξη που θα εισάγουμε υπάρχει ή οχι. Σε περίπτωση που υπάρχει, τότε απλά αυξάνουμε κατά μια μονάδα την μεταβλητή εμφάνισης της λέξης. Σε διαφορετική περίπτωση, τότε δεσμεύουμε μια μονάδα περισσότερο χώρο (βλ. Πρόγραμμα \ref{listing:2} - Συνάρτηση \en ReallocateArray(int) \gr ) για την \en Array\gr. Στη συνέχεια, αφού έχει δεσμευτεί χώρος, απλά εισάγουμε την λέξη στον πίνακα και θέτουμε ότι η λέξη είναι η πρώτη (δηλαδή έχει πλήθος εμφανίσεων μια φορές).


\en
\begin{listing}[ht]
\begin{minted}[frame=lines, framesep=1em]{cpp}

void unorderedArray::Insert(string word)
{
    long long unsigned int temp, times;
    if(Find(word, temp, times))
        Array[temp].times++;
    else
    {
        ReallocateArray(1);
        Array[First_Free_Element-1].value = word;
        Array[First_Free_Element-1].times = 1;
    }
}

bool unorderedArray::ReallocateArray(int n)
{
    Arr* temp = new (nothrow) Arr[First_Free_Element+n];

    if (temp == nullptr) return false;

    for (long long unsigned int element = 0; element < First_Free_Element; element++)
    {
        temp[element].value = Array[element].value;
        temp[element].times= Array[element].times;
    }

    delete[] Array;
    Array = temp;

    First_Free_Element++;
    return true;
}

\end{minted}
\caption{Δημιουργία των συναρτήσεων Insert και RelocateArray του αταξινόμητου πίνακα}
\label{listing:2}
\end{listing}
\gr


\subsection{Μέθοδος αναζήτησής}

Σε έναν μη ταξινομημένο πίνακα, η λειτουργία αναζήτησης θα εκτελεστεί με γραμμική διέλευση από το πρώτο στοιχείο ($i=0$) στο τελευταίο στοιχείο ($i=n-1$). Η διαδικασία αυτή ως προς την ταχύτητα εύρεσης ενός στοιχείου $k$ (όπου $k$ το ενδιαφερόμενο στοιχείο), παρουσιάζει καθυστέρησή ανάλογα με τη θέση $i$ που βρίσκεται το στοιχείο $k$.

Με βάση τον Πίνακα \ref{table:1} παρατηρούμε ότι υπάρχει χειρότερη περίπτωση $n$ συγκρίσεων σε περίπτωση που το $k$ στοιχείο βρίσκεται στη θέση $n-1$ του πίνακα ή δεν περιέχεται. Έτσι λοιπόν, ο αλγόριθμος της σειριακής αναζήτησης έχει πολυπλοκότητα χειρότερης περίπτωσής $O(n)$.

Όπως φαίνεται στο Πρόγραμμα \ref{listing:3}, κάθε φορά που καλείται η συνάρτηση, γίνεται έλεγχος σε περίπτωση που ο πίνακας είναι άδειος. Για κάθε περίπτωση που υπάρχουν έστω ένα ή περισσότερα στοιχεία/λέξεις μέσα στον πίνακα, τότε σειριακά επιτελείται η αναζήτηση. Αν το επιθυμητό στοιχείο βρεθεί, τότε, με αναφορά επιστρέφεται η θέση στην οποία βρέθηκε το στοιχείο, πόσες φορές βρέθηκε (που υπάρχει ήδη από την εισαγωγή) και τέλος επιστρέφεται ότι βρέθηκε. Για κάθε άλλη περίπτωση επιστρέφονται -- με αναφορά -- μηδενικές εμφανίσεις και \en false\gr.

\en
\begin{listing}[ht]
\begin{minted}[frame=lines, framesep=1em]{cpp}

bool unorderedArray::Find(string object, int &temp, int &existance_times)
{
    if(First_Free_Element == 0)
        return false;
        
    for (int i = 0; i < First_Free_Element; i++)
    {
        if(Array[i].value==object)
        {
            temp = i;
            existance_times = Array[i].times;
            return true;
        }
    }

    existance_times = 0;
    return false;
}

\end{minted}
\caption{Δημιουργία της συνάρτησής Find του αταξινόμητου πίνακα}
\label{listing:3}
\end{listing}

\subsection{Μέθοδος διαγραφής}

Η διαγραφή στον αταξινόμητο πίνακα είναι χρονοβόρα καθώς γίνεται χρήση της συνάρτησης \en Find \gr και διαπερνούμε όλα τα στοιχεία του πίνακα. Η μεθοδολογία που ακολουθούμε για να καλύψουμε τις κενές θέσεις είναι να αλλάζουμε την θέση του κάθε στοιχείου του πίνακα κατά μια θέση αρνητικά, με βάση τη θέση την οποία βρέθηκε το επιθυμητό στοιχείο που είναι προς διαγραφή.

Υπό αλγοριθμικής σκέψης, θα λέγαμε ότι, αν $k$ το στοιχείο προς αναζήτηση και $P(k)$ η θέση στην οποία βρέθηκε, τότε όλα τα στοιχεία με $ \mbox{θέσεις} \geq P(k)$ θα αντιμετατεθούν τις θέσεις τους κατά μείον μια θέση από την αρχική τους.

Υλοποιώντας την σκέψη μας με $C++$ κώδικα (βλ. Πρόγραμμα \ref{listing:4}), αρχικά θα ελέγξουμε αν το στοιχείο που επιθυμούμε να διαγράψουμε υπάρχει. Αν δεν υπάρχει τότε τερματίζουμε την συνάρτηση και επιστρέφουμε \en false\gr. Διαφορετικά, υλοποιούμε την παραπάνω σκέψη μας σε αλγόριθμο. Τέλος, μειώνουμε την τελευταία ελεύθερη θέση του πίνακα κατά μια μονάδα και επιστρέφουμε \en true\gr.

\en
\begin{listing}[ht]
\begin{minted}[frame=lines, framesep=1em]{cpp}

bool unorderedArray::Delete(string object)
{
    long long unsigned int temp, existance_times;
    if (!Find(object, temp, existance_times))
        return false;

    for (long long unsigned int position = temp; position < First_Free_Element - 1; position++)
    {
        Array[position].value = Array[position + 1].value;
        Array[position].times = Array[position + 1].times;
    }

    First_Free_Element--;
    return true;
}

\end{minted}
\caption{Δημιουργία της συνάρτησής Delete του αταξινόμητου πίνακα}
\label{listing:4}
\end{listing}

\subsection{Σχολιασμός και χρόνοι εκτέλεσης}

Ο χρόνος εισαγωγής σε έναν αταξινόμητο πίνακα, σαφώς και είναι λιγότερος σε σχέση με την δομή του ταξινομημένου πίνακα. Κάθε στοιχείο μεταφορτώνεται στο τέλος του πίνακα, οπότε, κατ-ανάγκη, δεν την καθιστά, ως προς την εισαγωγή, χειρότερη δομή.

\gr
\begin{table}[!ht]
\centering
\begin{tabular}{||c c c||} 
 \hline
 Δομή  & Χρόνος Εισαγωγής & Χρόνος Αναζήτησης/10χιλ. λέξεις \\
 \hline\hline
 Αταξινόμητος πίνακας & $\approx$10.9451192 ώρες & $\approx$33.1032167 λεπτά \\
 \hline
\end{tabular}
\caption{Χρόνοι εκτέλεσης εισαγωγής και αναζήτησης για τον αταξινόμητο πίνακα}
\label{table:3}
\end{table}

Όσο για την αναζήτηση, επειδή κάθε στοιχείο αναζητείται σειριακά, δηλαδή συγκρίνουμε όλα τα προηγούμενα στοιχεία με το στοιχείο που ψάχνουμε, καθιστά την δομή αργή. Αν δώσουμε μια εκτίμηση για δέκα χιλιάδες λέξεις έχουμε τα παραπάνω χρονικά αποτελέσματα (Πίνακας \ref{table:3}).